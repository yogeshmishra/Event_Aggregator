/* -*- C++ -*-   vim: set syntax=cpp:
 * CONTENT: 
 *
 * (1) Includes for required standard headers.
 * (2) Definitions of options and settings for the particular application.
 * (3) #include <quex/code_base/definitions> for default settings.
 * (4) Lexical Analyzer class EasyLexer and its memento class.
 * (5) Constructor and init core of EasyLexer.
 * (6) Memento pack and unpack functions.
 *
 * File content generated by Quex 0.60.2.
 *
 * (C) 2005-2010 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY                                                      */
#ifndef __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____QUEX____EASYLEXER
#define __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____QUEX____EASYLEXER

#ifdef      __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
    /* In case that multiple lexical analyzers are used the same header
     * files are compiled with a different setting of the macros. The
     * undef of the include guards happens in the following file.              */
#   include <quex/code_base/include-guard-undef>
#   include <quex/code_base/analyzer/member/token-sending-undef.i>
#   undef   __QUEX_INCLUDE_GUARD__ANALYZER__CONFIGURATION____QUEX____EASYLEXER
#else
#   define  __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
#endif

#include "EasyLexer-configuration.h"

#include <quex/code_base/definitions>

struct  QUEX_NAME(Engine_tag);
struct  QUEX_NAME(Memento_tag);
QUEX_TYPE0_ANALYZER;    /* EasyLexer */
typedef __QUEX_TYPE_ANALYZER_RETURN_VALUE  (*QUEX_NAME(AnalyzerFunctionP))(QUEX_TYPE_ANALYZER*);

/* Token Class Declaration must preceed the user's header, so that the user
 * can refer to it at ease.                                                    */
QUEX_TYPE0_TOKEN;

/* START: User defined header content _________________________________________
 *        Must come before token class definition, since the token class 
 *        might rely on contents of the header.                                */


/* END: _______________________________________________________________________*/
#if defined(__QUEX_OPTION_CONVERTER_HELPER)
#   include "quex/code_base/converter_helper/unicode"
#endif
#include <quex/code_base/analyzer/headers>

#include "EasyLexer-token_ids.h"
#include "EasyLexer-token.h"


QUEX_NAMESPACE_MAIN_OPEN 

enum {
    QUEX_NAME(ModeID_ABBREVIATION) = 0,
    QUEX_NAME(ModeID_NEW_SENTENCE) = 1,
    QUEX_NAME(ModeID_NORMAL) = 2
};
    
        extern QUEX_NAME(Mode)  QUEX_NAME(ABBREVIATION);
        extern QUEX_NAME(Mode)  QUEX_NAME(NEW_SENTENCE);
        extern QUEX_NAME(Mode)  QUEX_NAME(NORMAL);


extern     __QUEX_TYPE_ANALYZER_RETURN_VALUE QUEX_NAME(ABBREVIATION_analyzer_function)(QUEX_TYPE_ANALYZER*);
extern     void QUEX_NAME(ABBREVIATION_on_entry)(QUEX_TYPE_ANALYZER*, const QUEX_NAME(Mode)*);
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern     bool QUEX_NAME(ABBREVIATION_has_base)(const QUEX_NAME(Mode)*);
extern     bool QUEX_NAME(ABBREVIATION_has_entry_from)(const QUEX_NAME(Mode)*);
extern     bool QUEX_NAME(ABBREVIATION_has_exit_to)(const QUEX_NAME(Mode)*);
#endif
extern     __QUEX_TYPE_ANALYZER_RETURN_VALUE QUEX_NAME(NEW_SENTENCE_analyzer_function)(QUEX_TYPE_ANALYZER*);
extern     void QUEX_NAME(NEW_SENTENCE_on_exit)(QUEX_TYPE_ANALYZER*, const QUEX_NAME(Mode)*);
extern     void QUEX_NAME(NEW_SENTENCE_on_entry)(QUEX_TYPE_ANALYZER*, const QUEX_NAME(Mode)*);
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern     bool QUEX_NAME(NEW_SENTENCE_has_base)(const QUEX_NAME(Mode)*);
extern     bool QUEX_NAME(NEW_SENTENCE_has_entry_from)(const QUEX_NAME(Mode)*);
extern     bool QUEX_NAME(NEW_SENTENCE_has_exit_to)(const QUEX_NAME(Mode)*);
#endif
extern     __QUEX_TYPE_ANALYZER_RETURN_VALUE QUEX_NAME(NORMAL_analyzer_function)(QUEX_TYPE_ANALYZER*);
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern     bool QUEX_NAME(NORMAL_has_base)(const QUEX_NAME(Mode)*);
extern     bool QUEX_NAME(NORMAL_has_entry_from)(const QUEX_NAME(Mode)*);
extern     bool QUEX_NAME(NORMAL_has_exit_to)(const QUEX_NAME(Mode)*);
#endif



typedef struct QUEX_NAME(Memento_tag) {
#   include <quex/code_base/analyzer/EngineMemento_body>

    /* Con- and Destruction are **not** necessary in C. No con- or de-
     * structors of members need to be triggered.                              */

/* START: User's memento extentions ___________________________________________*/

/* END: _______________________________________________________________________*/
} QUEX_NAME(Memento);

QUEX_NAMESPACE_MAIN_CLOSE 

#include <quex/code_base/temporary_macros_on>

QUEX_NAMESPACE_MAIN_OPEN 

typedef struct EasyLexer_tag {

#include <quex/code_base/analyzer/Engine_body>
#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)this)
/* START: User's class body extensions _____________________________________________*/

/* END: ____________________________________________________________________________*/
#undef  self

} EasyLexer;

QUEX_NAMESPACE_MAIN_CLOSE
#include <quex/code_base/temporary_macros_off>

#endif /* __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____QUEX____EASYLEXER */
